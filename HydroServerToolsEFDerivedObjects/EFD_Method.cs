using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using System.Data.Entity;

using ODM_1_1_1EFModel;

using HydroserverToolsBusinessObjects;
using HydroServerToolsEFDerivedObjects.Interfaces;

namespace HydroServerToolsEFDerivedObjects
{
    public class EFD_Method : Method, ICuahsiUpload<Method>
    {
        //Interface members...
        //NOTE: Since the ODM classes are auto-generated by Visual Studio and not subject to manual editing,
        //      the Entity-Framework-Derived classes implement the ICuahsiUpload methods.
        //      Thus the field name strings refer to ODM class fields...
        private static readonly Dictionary<int, string> _fields = new Dictionary<int, string>()
        {
            {0, "MethodCode"},
            {1, "MethodDescription"},
            {2, "MethodLink"}
        };

        //Return a list of field names for use in seach processing...
        public List<string> GetFields(FieldType ft)
        {
            //For now, just return a list...
            var result = new List<string>();

            switch (ft)
            {
                case FieldType.ftSearching:
                    //All field names...
                    foreach (var kvp in _fields)
                    {
                        result.Add(kvp.Value);
                    }
                    break;
                case FieldType.ftDuplicatesCheck:
                    result.Add(_fields[0]); //MethodCode...
                    break;
                case FieldType.ftUpdatesCheck:
                    result.Add(_fields[1]); //MethodDescription
                    result.Add(_fields[2]); //MethodLink
                    break;
                default:
                    //Unknown field type - take no action...
                    break;
            }

            return result;
        }

        //Return a dictionary of field positions, names for use in sort processing...
        public Dictionary<int, string> GetFieldsForSorting()
        {
            //For now, just return a dictionary...
            var result = new Dictionary<int, string>();

            foreach (var kvp in _fields)
            {
                result.Add(kvp.Key, kvp.Value);
            }

            return result;
        }

        //Copy contents to the specified EntityFramework model type...
        public bool CopyTo(Method odmType, StringBuilder sbError)
        {
            //Validate/initialize input parameters...
            bool bResult = true;    //Assume success

            if (null != odmType && null != sbError)
            {
                sbError.Clear();
                var myType = GetType();
                var lhsType = odmType.GetType();

                //Scan fields of current instance... 
                foreach (var kvp in _fields)
                {
                    // Use null coalescing operator (??) to avoid null reference errors...
                    // source: http://stackoverflow.com/questions/16490509/how-to-assign-empty-string-if-the-value-is-null-in-linq-query
                    var rhs = (myType.GetProperty(kvp.Value).GetValue(this, null) ?? String.Empty).ToString();

                    if (string.IsNullOrWhiteSpace(rhs))
                    {
                        sbError.AppendFormat(Resources.IMPORT_VALUE_CANNOTBEEMPTY, kvp.Value);
                        bResult = false;
                    }
                    else if (BusinessObjectsUtils.containsSpecialCharacters(rhs))
                    {
                        sbError.AppendFormat(Resources.IMPORT_VALUE_INVALIDCHARACTERS, kvp.Value);
                        bResult = false;
                    }

                    if (bResult)
                    {
                        //Success - assign to LHS...
                        lhsType.GetProperty(kvp.Value).SetValue(odmType, rhs);
                    }
                    else
                    {
                        break;  //Error - break
                    }
                }
            }

            //Processing complete - return
            return bResult;
        }

        //Per the input DbSet instance, remove all records...
        public bool QueueDeleteAll(DbSet<Method> dbSet)
        {
            bool bResult = false;   //Assume nothing queued...

            //Validate/initialize input parameters...
            if (null != dbSet)
            {
                //Parameters valid - select rows for deletion...
                var rows = from o in dbSet
                           where o.MethodID != 0
                           select o;

                if (0 < rows.Count())
                {
                    //Rows found - queue for deletion...
                    dbSet.RemoveRange(rows);
                    bResult = true;
                }

            }

            //Processing complete - return result...
            return bResult;
        }

    }
}
